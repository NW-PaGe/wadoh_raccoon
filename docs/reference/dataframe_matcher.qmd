# dataframe_matcher { #wadoh_raccoon.dataframe_matcher }

`dataframe_matcher`



## Classes

| Name | Description |
| --- | --- |
| [DataFrameMatcher](#wadoh_raccoon.dataframe_matcher.DataFrameMatcher) | A utility class for matching records. |

### DataFrameMatcher { #wadoh_raccoon.dataframe_matcher.DataFrameMatcher }

```python
dataframe_matcher.DataFrameMatcher(
    self,
    df_src: pl.DataFrame,
    df_ref: pl.DataFrame,
    first_name: str | tuple[str, str],
    last_name: str | tuple[str, str],
    dob: str | tuple[str, str],
    spec_col_date: str | tuple[str, str],
    key: str | list | None = None,
    threshold: int | float = 80,
    day_max: int | None = None,
    business_day_max: int | None = None,
)
```

A utility class for matching records.

This class provides functionality to match submissions to cases (epi 
data) based on exact matching via accessions or fuzzy matching based on
patient demographics

#### Parameters {.doc-section .doc-section-parameters}

<code>[**df_src**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.DataFrame]{.parameter-annotation}</code>

:   Source dataframe containing any Key(s) and patient demographics.

<code>[**df_ref**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.DataFrame]{.parameter-annotation}</code>

:   Reference queried dataframe containing patient demographics.

<code>[**first_name**]{.parameter-name} [:]{.parameter-annotation-sep} [str \| tuple\[str, str\]]{.parameter-annotation}</code>

:   The first name demographic column name in the source and reference dataframes. If the names are different, they should be provided in a tuple containing the source name first, followed by the reference name.

<code>[**last_name**]{.parameter-name} [:]{.parameter-annotation-sep} [str \| tuple\[str, str\]]{.parameter-annotation}</code>

:   The last name demographic column name in the source and reference dataframes. If the names are different, they should be provided in a tuple containing the source name first, followed by the reference name.

<code>[**dob**]{.parameter-name} [:]{.parameter-annotation-sep} [str \| tuple\[str, str\]]{.parameter-annotation}</code>

:   The birth date demographic column name in the source and reference dataframes. If the names are different, they should be provided in a tuple containing the source name first, followed by the reference name.

<code>[**spec_col_date**]{.parameter-name} [:]{.parameter-annotation-sep} [str \| tuple\[str, str\]]{.parameter-annotation}</code>

:   The specimen collection date column name in the source and reference dataframes. If the names are different, they should be provided in a tuple containing the source name first, followed by the reference name.

<code>[**key**]{.parameter-name} [:]{.parameter-annotation-sep} [str \| list \| None]{.parameter-annotation} [ = ]{.parameter-default-sep} [None]{.parameter-default}</code>

:   The key (or list of keys) which group to a distinct source record. Only one match can be returned per distinct key. If no key given, each row in the source df will be treated as a distinct record to be matched.

<code>[**threshold**]{.parameter-name} [:]{.parameter-annotation-sep} [int \| float]{.parameter-annotation} [ = ]{.parameter-default-sep} [80]{.parameter-default}</code>

:   The inclusive fuzzy scoring threshold used to filter fuzzy matches. Matches with a score  at or above the threshold will be returned in the fuzzy matched object. Defaults to 80.

<code>[**day_max**]{.parameter-name} [:]{.parameter-annotation-sep} [int \| None]{.parameter-annotation} [ = ]{.parameter-default-sep} [None]{.parameter-default}</code>

:   The max number of days between reference and source specimen collection dates a fuzzy matched record can have and be returned as a match

<code>[**business_day_max**]{.parameter-name} [:]{.parameter-annotation-sep} [int \| None]{.parameter-annotation} [ = ]{.parameter-default-sep} [None]{.parameter-default}</code>

:   The max number of business days between reference and source specimen collection dates a fuzzy matched record can have and be returned as a match. Business days are counted as weekdays (holidays are not accounted for).

#### Returns {.doc-section .doc-section-returns}

<code>[**fuzzy_matched_review**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.DataFrame]{.parameter-annotation}</code>

:   records that successfully fuzzy matched

<code>[**fuzzy_without_demo**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.DataFrame]{.parameter-annotation}</code>

:   records missing demographics and can't be matched

<code>[**fuzzy_matched_none**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.DataFrame]{.parameter-annotation}</code>

:   records that did not have any match

<code>[**fuzzy_matched_roster**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.DataFrame]{.parameter-annotation}</code>

:   records that had an exact match to reference dataframe

#### Examples {.doc-section .doc-section-examples}

**Step 1:** Import the packages:
```{python}
from wadoh_raccoon import dataframe_matcher as dfm
import polars as pl
from datetime import date

```

**Step 2:** The fuzzy matching functions need two dataframes to match. Bring your dataframe and the reference dataframe:
```{python}
# Create example data
your_df = pl.DataFrame({
    'submission_number': [453278555, 453278555, 887730141],
    'first_name': ['DAVIS', 'DAVIS', 'GRANT'],
    'last_name': ['SMITHDAVIS', 'SMITHDAVIS', 'MITHCELL'],
    'sub_collection_date': [date(2024, 11, 29), date(2024, 11, 29), date(2024, 12, 2)],
    'birth_date': [date(1989, 7, 15), date(1989, 7, 15), date(1990, 6, 21)]
})

reference_df = pl.DataFrame({
    'CASE_ID': [100000032, 100000041, 100020000],
    'first_name_reference': ['DAVID', 'DAVID', 'TRASH'],
    'last_name_reference': ['SMITDAVIS', 'SMITDAVIS', 'PANDA'],
    'ref_collection_date': [date(2024, 11, 29), date(2024, 8, 31), date(2024, 8, 31)],
    'birth_date': [date(1989, 7, 15), date(1989, 7, 15), date(1990, 6, 21)]
})
```

**Step 3:** Initalize the fuzzy matching class and input which dataframes and columns you are matching on
```{python}
fuzzy_init = dfm.DataFrameMatcher(
    df_src=your_df,
    df_ref=reference_df,
    first_name=('first_name', 'first_name_reference'),
    last_name=('last_name', 'last_name_reference'),
    dob='birth_date',
    spec_col_date=('sub_collection_date', 'ref_collection_date'),
    key='submission_number',
    threshold=80  # set what kind of fuzzy threshold you want, 100 being exact match
)
```

**Step 4:** Run fuzzy matching! This will output data on what matched and what didn't match.

```{python}
#| class-output: box
result = fuzzy_init.match()
```

You can also examine the output dataframes by pulling them out of the result class, like this:


```python
result.fuzzy_unmatched
```
```{python}
#| echo: false
from wadoh_raccoon.utils import helpers
helpers.gt_style(df_inp=result.fuzzy_unmatched)
```

```python
result.fuzzy_matched
```
```{python}
#| echo: false
from wadoh_raccoon.utils import helpers
helpers.gt_style(df_inp=result.fuzzy_matched)
```
<br>
<br>
<br>

#### Methods

| Name | Description |
| --- | --- |
| [fuzzy_match](#wadoh_raccoon.dataframe_matcher.DataFrameMatcher.fuzzy_match) | Where the magic happens. Do the fuzzy matching to the dataframe |

##### fuzzy_match { #wadoh_raccoon.dataframe_matcher.DataFrameMatcher.fuzzy_match }

```python
dataframe_matcher.DataFrameMatcher.fuzzy_match(dob_match)
```

Where the magic happens. Do the fuzzy matching to the dataframe

###### Parameters {.doc-section .doc-section-parameters}

<code>[**dob_match**]{.parameter-name} [:]{.parameter-annotation-sep} []{.parameter-annotation}</code>

:   the dataframe that has records grouped by their dob match

###### Returns {.doc-section .doc-section-returns}

<code>[**fuzzy_matched**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.DataFrame]{.parameter-annotation}</code>

:   dataframe with matches that met or exceeded the fuzzy matching score threshold

<code>[**fuzzy_unmatched**]{.parameter-name} [:]{.parameter-annotation-sep} [pl.DataFrame]{.parameter-annotation}</code>

:   dataframe with matches that failed to meet the fuzzy matching score threshold

###### Examples {.doc-section .doc-section-examples}

```python
from wadoh_raccoon import dataframe_matcher as dfm
import polars as pl
from datetime import date

# Create example data
df = pl.DataFrame({
    'submission_number': [453278555, 453278555, 887730141],
    'first_name_clean': ['DAVIS', 'DAVIS', 'GRANT'],
    'last_name_clean': ['SMITHDAVIS', 'SMITHDAVIS', 'MITHCELL'],
    'submitted_collection_date': [date(2024, 11, 29), date(2024, 11, 29), date(2024, 12, 2)],
    'submitted_dob': [date(1989, 7, 15), date(1989, 7, 15), date(1990, 6, 21)],
     'CASE_ID': [100000032, 100000041, None],
    'first_name_clean_right': ['DAVID', 'DAVID', None],
    'last_name_clean_right': ['SMITDAVIS', 'SMITDAVIS', None],
     'reference_collection_date': [date(2024, 11, 29), date(2024, 8, 31), None]
})

# Init dataframe matcher
# (this is not how to use the instance but input data not used in this example)
instance = dfm.DataFrameMatcher(df, df)
fuzzy_matched, fuzzy_unmatched = instance.fuzzy_match(dob_match=df)
```

Fuzzy match found:
```python
helpers.gt_style(df_inp=fuzzy_matched)
```

no matches found:
```python
helpers.gt_style(df_inp=fuzzy_matched_none)
```